document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>');
(function () {
'use strict';

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var Component = function () {
	function Component() {
		classCallCheck(this, Component);
	}

	createClass(Component, [{
		key: "setState",
		value: function setState(state) {
			// assign(this, {
			// 	state,
			// 	prevState: { ...this.state },
			//  })

			console.log("settinf", state);
			// this.onStateUpdate()
		}
	}, {
		key: "onStateUpdate",
		value: function onStateUpdate() {}
	}]);
	return Component;
}();

var MOUSE_DOWN = "App.MOUSE_DOWN";
var MOUSE_UP = "App.MOUSE_UP";
var MOUSE_MOVE = "App.MOUSE_MOVE";

/*eslint no-console: "off"*/

var assign$1 = Object.assign;

var Store = function () {
	function Store() {
		var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
		    _ref$reducers = _ref.reducers,
		    reducers = _ref$reducers === undefined ? {} : _ref$reducers;

		classCallCheck(this, Store);

		var reducerKeys = Object.keys(reducers);
		assign$1(this, {
			reducers: reducers,
			reducerKeys: reducerKeys,
			subscribers: [],
			state: this.getInitialStateObjectFromReducerKeys({ reducerKeys: reducerKeys, reducers: reducers })
		});

		// setTimeout(() => {
		// 	this.dispatch({
		// 		type: `STORE_INIT`,
		// 	})
		// })
	}

	createClass(Store, [{
		key: "mapStoreToStateObject",
		value: function mapStoreToStateObject(_ref2) {
			var state = _ref2.state,
			    store = _ref2.store,
			    reducer = _ref2.reducer;

			return _extends({}, state, defineProperty({}, store, reducer()));
		}
	}, {
		key: "getInitialStateObjectFromReducerKeys",
		value: function getInitialStateObjectFromReducerKeys() {
			var _this = this;

			var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			    _ref3$reducerKeys = _ref3.reducerKeys,
			    reducerKeys = _ref3$reducerKeys === undefined ? [] : _ref3$reducerKeys,
			    reducers = _ref3.reducers;

			return reducerKeys.reduce(function (state, store) {
				return _this.mapStoreToStateObject({
					state: state,
					store: store,
					reducer: reducers[store]
				});
			}, {});
		}
	}, {
		key: "reduceStateObject",
		value: function reduceStateObject(_ref4) {
			var state = _ref4.state,
			    store = _ref4.store,
			    action = _ref4.action,
			    reducer = _ref4.reducer;

			return _extends({}, state, defineProperty({}, store, reducer({
				state: state[store],
				action: action
			})));
		}
	}, {
		key: "dispatch",
		value: function dispatch() {
			var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
			    _ref5$type = _ref5.type,
			    type = _ref5$type === undefined ? "" : _ref5$type,
			    _ref5$value = _ref5.value,
			    value = _ref5$value === undefined ? "" : _ref5$value,
			    mute = _ref5.mute;

			var reducers = this.reducers,
			    reducerKeys = this.reducerKeys,
			    state = this.state,
			    reduceStateObject = this.reduceStateObject;

			var action = {
				type: type,
				value: value
			};
			var nextState = reducerKeys.reduce(function (state, store) {
				return reduceStateObject({
					state: state,
					store: store,
					action: action,
					reducer: reducers[store]
				});
			}, _extends({}, state));

			!mute && this.logStateChange({ type: type, state: state, action: action, nextState: nextState });
			this.setState({ state: nextState });
		}
	}, {
		key: "setState",
		value: function setState(_ref6) {
			var state = _ref6.state;

			assign$1(this, { state: state });
			this.onStateUpdate({ state: state });
		}
	}, {
		key: "onStateUpdate",
		value: function onStateUpdate() {
			var _this2 = this;

			this.subscribers.map(function (subscriber) {
				return subscriber(_this2);
			});
		}
	}, {
		key: "subscribe",
		value: function subscribe(callback) {
			assign$1(this, { subscribers: [].concat(toConsumableArray(this.subscribers), [callback]) });
			callback(this);
		}
	}, {
		key: "logStateChange",
		value: function logStateChange(_ref7) {
			var type = _ref7.type,
			    state = _ref7.state,
			    action = _ref7.action,
			    nextState = _ref7.nextState;

			console.group("Action @ " + type);
			console.log("prev state\t", state);
			console.log("action\t\t", action);
			console.log("next state\t", nextState);
			console.groupEnd();
		}
	}]);
	return Store;
}();

var connect = function connect(Component, name) {
	return function (_Component) {
		inherits(ConnectedComponent, _Component);

		function ConnectedComponent() {
			classCallCheck(this, ConnectedComponent);
			return possibleConstructorReturn(this, (ConnectedComponent.__proto__ || Object.getPrototypeOf(ConnectedComponent)).apply(this, arguments));
		}

		createClass(ConnectedComponent, [{
			key: "setState",
			value: function setState(store) {
				console.log("ConnectedComponent.setState()");
				if (store instanceof Store) {
					this.store = store;
					get(ConnectedComponent.prototype.__proto__ || Object.getPrototypeOf(ConnectedComponent.prototype), "setState", this).call(this, store.state[name]);
				} else {}
			}
		}]);
		return ConnectedComponent;
	}(Component);
};

// import Canvas from './canvas'
// import ShitCannon from './shit-cannon'

var App = function (_Component) {
  inherits(App, _Component);

  function App() {
    classCallCheck(this, App);
    return possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
  }

  return App;
}(Component);

var App$1 = connect(App, 'app');

//
// import {
//   ADD_AIRBOURNE_SHIT,
// } from '../actions/shit-cannon'

var initialState = {
  isMouseDown: undefined,
  mousePosition: {
    x: undefined,
    y: undefined
  }
};

var appReducer = (function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$state = _ref.state,
      state = _ref$state === undefined ? initialState : _ref$state,
      _ref$action = _ref.action,
      action = _ref$action === undefined ? {} : _ref$action;

  console.log('no state set', state);
  switch (action.type) {
    case MOUSE_DOWN:
      return _extends({}, state, {
        isMouseDown: true,
        mousePosition: _extends({}, action.value)
      });

    case MOUSE_UP:
      return _extends({}, state, {
        isMouseDown: false,
        mousePosition: _extends({}, action.value)
      });

    case MOUSE_MOVE:
      return _extends({}, state, {
        mousePosition: _extends({}, action.value)
      });
  }

  return _extends({}, state);
});

var store = new Store({
	reducers: {
		app: appReducer
	}
});

var app = new App$1({
	canvasElement: document.getElementById('canvas')
});

store.subscribe(function (state) {
	app.setState(state);
});

}());
